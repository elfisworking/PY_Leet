# 背包问题的一些代码实现

主要参考[背包九讲](..\参考资料\Pack-PDF-Comzyh.pdf)

## 01背包问题

问题描述：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

状态转移方程
$$
f[i][j] = max(f[i - 1][j],f[i - 1][j - c[i]] + w[i])
$$
代码实现
```python
for i in range(1,N + 1):
    for j in range(V + 1):
        if c[i] > j:
            f[i][j] = f[i - 1][j]
        else:
            f[i][j] = max(f[i - 1][j],f[i][j - c[i]] + w[i]) 
```
对其进行优化从二维降至一维，注意这里`j`的方向

```python
for i in range(1,N + 1):
    for j in range(V,-1,-1):
        f[j] = max(f[j],f[j - c[i]] + w[i])
```
再进行一个常数级别的优化
```python
for i in range(1,N+1):
    for j in range(V,c[i]-1,-1):
        f[j] = max(f[j],f[j - c[i]] + w[i])
```

## 完全背包问题
问题描述：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

转移方程
$$
f[i][j] = max(f[i - 1][j - k * c[i]] + k * w[i]) \ \ when \le 0\le k * c[i] \le V
$$
代码实现
```python
for i in range(N + 1):
    for j in range(V + 1):
        K = V/c[i]
        for k in range(K+1):
            f[i][j] = max(f[i][j],f[i - 1][j - k * c[i]] + k * w[i]) 
```

对其进行优化从二维降至一维,注意这里面`j`的方向
```python
for i in range(1,N + 1):
    for j in range(V + 1):
        f[j] = max(f[j],f[j - c[i]] + w[i])
```
跟01背包同理，也可以进行一个常数级别的优化
```python
for i in range(1,N + 1):
    for j in range(c[i],V + 1):
        f[j] = max(f[j],f[j - c[i]] + w[i])      
```
当前我们也可以将这个问题转化为01背包个问题，因为每件物品最多只能选择V/c[i]个。那么我们就可以将第i个物品转化为V/c[i]件费用和价值都相同的物品。

其它的优化：
* 若两件物品i、j满足c[i] <= c[j]且w[i] >= w[j]，那么可以将j物品过滤掉。
* 首先将费用大于V的物品去掉然后使用类似计数排序法的做法，计算出费用相同物品中价值最高的是哪一个。

## 多重背包问题
问题描述：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

转移方程
$$
f[i][j] = max(f[v-1][j - k * c[i]+k * w[i]]) \ \ \ when\ 0\le k \le n[i]
$$
这道题目可以直接转化为01背包问题。
不过这里我们可以使用二进制法来降低复杂度。方法如下：
将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值
均是原来的费用和价值乘以这个系数。使这些系数分别为$1,2,4,. . . ,2^{k-1}
,n[i] − 2^k + 1 $，且k是满足$n[i] − 2^k + 1 > 0$的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

代码实现
```python
for i in range(1,N + 1):
    num = min(n[i],V/c[i])
    k = 1
    while num > 0:
        if k > num:
            k = num
        num -=k 

        # 01背包部分
        for j in range(V,c[i] * k,-1):
            f[j] = max(f[j], f[j - k * c[i]] + k * w[i])

        k *= 2
```

## 混合背包问题

问题描述：此问题将01背包问题、完全背包问题和多重背包问题混合起来。也就是说，在此类问题中有的物品可以取一次（01背包问题），有的物品可以取无限次（完全背包），有的物品可以取的次数有限制（多重背包）

代码实现
```python
for i in range(1,N+1):
    if n[i]属于01背包:
        for j in range(V,-1,-1):
            f[v] = max(f[v],f[v - c[i]] + w[i])
    elif n[i]属于完全背包：
        for j in range(V+1):
            f[v] = max(f[v], f[v - c[i]] + w[i])
    else: # 属于多重背包
        num = min(n[i],V/c[i])
    k = 1
    while num > 0:
        if k > num:
            k = num
        num -=k 

        # 01背包部分
        for j in range(V,c[i] * k,-1):
            f[j] = max(f[j], f[j - k * c[i]] + k * w[i])
        k *= 2
```
## 二维费用的背包问题
问题描述：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。

思路：将一维转化为二维，增加一个状态维度

转移方程
$$
f[i][v][u] = Max \left\{\begin{matrix}f[i-1][v][u]
 \\f[i-1][v-a[i]][v-b[i]]+w[i]
\end{matrix}\right.
$$
当然这里也可以采取相同的降维的方法，将这个三维矩阵降至二维矩阵。

代码如下
```python
for i in range(1,N+1):
    for v in range(V+1):
        for u in range(U+1):
            f[v][u] = max(f[v][u],f[v - a[i]][u - b[i]] + w[i])
```

**物品总数的限制** 
有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。

## 分组的背包问题
问题描述：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若k组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

这个问题变成了每组物品有若干种策略：是选择本组的一件，还是本组中的物品一个也不选。换句话来说，就是转移方程中f[k][v]表示前k组物品花费费用v能取得的最大权值，转移方程如下。

转移方程
$$
f[k][v] = Max \left\{\begin{matrix}f[k-1][v]
& \\f[k-1][v-c[i]]+w[i] 
& i属于第k组
\end{matrix}\right.
$$

代码实现
```python
for k in K:
    for v in range(V,-1,-1):
        for i in range(1,len(k)+1):
            f[v] = max(f[v], f[v - c[i]] + w[i])
```
## 有依赖的背包问题
简化的问题描述：这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。

## 背包问题问法的变化
### 输出方案
一般来说，背包问题是要求一个最优值，但是有的背包问题要求输出这个最优值的方案。对于这个问题，可以采取如下的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的。换句话说，就是记录下它是由哪一个策略推出的，然后我们便可以根据这条策略找到上一个状态，以此内推。

以01背包为例，转移方程为$f[i][v] = max\left \{ f[i-1][v], f[i-1][v-c[i]]+w[i]\right \} $。这时可以再用一个数组g[i][v]，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v] = f[i − 1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。设最终状态为f[N][V]。

代码如下：
```python
i = N
v = V
while i > 0:
    if g[i][V] == 0:
        print("为选择第i项物品")
    elif g[i][v] == 1:
        print("选择了第",i,"项物品")
        v  = v - c[i]
    i = i -1
```
### 求方案总数
对于这类问题，我们一般需要把状态转移方程中的`max`改为`sum`即可。例如若每件物品均是完全背包中的物品，转移方程为：
$$
f[i][v] = sum(f[i-1][v],f[i][v-[i]]) \\ 初始化条件f[0][0] = 1
$$

### 最优方案的总数
这里面的最优方案是指物品总价值最大的方案。以01背包为例，代码如下：
```python
for i in range(1,N+1):
    for v in range(V+1):
        f[i][v] = max(f[i - 1][v],f[i - 1][v-c[i]] + w[i])
        g[i][v] = 0
        if f[i][v] = f[i - 1][v]:
            g[i][v] = g[i][v] + g[i-1][v]
        if f[i][v] = f[i - 1][v - c[i]] + w[i]:
            g[i][v] = g[i][v] + g[i-1][v-c[i]]
```
