# 背包问题的一些代码实现

主要参考[背包九讲](..\参考资料\Pack-PDF-Comzyh.pdf)

## 01背包问题

问题描述：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

状态转移方程
`f[i][j] = max(f[i - 1][j],f[i - 1][j - c[i]] + w[i])`
代码实现
```python
for i in range(N + 1):
    for j in range(V + 1):
        if c[i] > j:
            f[i][j] = f[i - 1][j]
        else:
            f[i][j] = max(f[i - 1][j],f[i][j - c[i]] + w[i]) 
```
对其进行优化从二维降至一维，注意这里`j`的方向

```python
for i in range(N + 1):
    for j in range(V,-1,-1):
        f[j] = max(f[j],f[j - c[i]] + w[i])
```
再进行一个常数级别的优化
```python
for i in range(N+1):
    for j in range(V,c[i]-1,-1):
        f[j] = max(f[j],f[j - c[i]] + w[i])
```

## 完全背包问题
问题描述：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

转移方程
`f[i][j] = max(f[i - 1][j - k * c[i]] + k * w[i])` 当 0<= k * c[i] <= V

代码实现
```python
for i in range(N + 1):
    for j in range(V + 1):
        K = V/c[i]
        for k in range(K+1):
            f[i][j] = max(f[i][j],f[i - 1][j - k * c[i]] + k * w[i]) 
```

对其进行优化从二维降至一维,注意这里面`j`的方向
```python
for i in range(N + 1):
    for j in range(V + 1):
        f[j] = max(f[j],f[j - c[i]] + w[i])
```
跟01背包同理，也可以进行一个常数级别的优化
```python
for i in range(N + 1):
    for j in range(c[i],V + 1):
        f[j] = max(f[j],f[j - c[i]] + w[i])      
```
当前我们也可以将这个问题转化为01背包个问题，因为每件物品最多只能选择V/c[i]个。那么我们就可以将第i个物品转化为V/c[i]件费用和价值都相同的物品。

其它的优化：
* 若两件物品i、j满足c[i] <= c[j]且w[i] >= w[j]，那么可以将j物品过滤掉。
* 首先将费用大于V的物品去掉然后使用类似计数排序法的做法，计算出费用相同物品中价值最高的是哪一个。

## 多重背包问题
问题描述：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

转移方程
`f[i][j] = max(f[v - 1][j - k * c[i]]+k * w[i])` 当 0<= k <= n[i]

这道题目可以直接转化为01背包问题。
不过这里我们可以使用二进制法来降低复杂度。方法如下：
将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值
均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,. . . ,2^(k−1)
,n[i] − 2^k + 1，且k是满足n[i] − 2^k + 1 > 0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

代码实现
```python
for i in range(N + 1):
    num = min(n[i],V/c[i])
    k = 1
    while num > 0:
        if k > num:
            k = num
        num -=k 

        # 01背包部分
        for j in range(V,c[i] * k,-1):
            f[j] = max(f[j], f[j - k * c[i]] + k * w[i])

        k *= 2
```

## 混合背包问题

问题描述：此问题将01背包问题、完全背包问题和多重背包问题混合起来。也就是说，在此类问题中有的物品可以取一次（01背包问题），有的物品可以取无限次（完全背包），有的物品可以取的次数有限制（多重背包）

代码实现
```python

```